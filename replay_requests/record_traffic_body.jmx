<?xml version="1.0" encoding="UTF-8"?>
<!--
Created by Sam Gleske
MIT Licensed - Copyright 2026 Sam Gleske - https://github.com/samrocketman/nexus-requests-analyzer

A test plan that records MD5 checksums of HTTP responses.  Use this to
establish a baseline of expected response bodies.  The checksums can later be
verified using verify_traffic_body.jmx.

Checksum files are organized by client file with a 1:1 line mapping:
  - checksums/1.tsv corresponds to clients/1.tsv
  - Each line in the checksum file matches the request on the same line

Checksum TSV format (tab-separated):
  counter  client_id  http_method  path  response_code  md5_checksum
-->
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Record Traffic Body Checksums">
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
    </TestPlan>
    <hashTree>
      <!-- HTTP connection settings for memory efficiency -->
      <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP Request Defaults" enabled="true">
        <stringProp name="HTTPSampler.connect_timeout">${__P(http_connect_timeout,5000)}</stringProp>
        <stringProp name="HTTPSampler.response_timeout">${__P(http_response_timeout,30000)}</stringProp>
      </ConfigTestElement>
      <hashTree/>

      <!--
        HTTP Authorization Manager for optional basic authentication.
        If http_user property is empty, no authentication is applied.
        Set via HTTP_USER and HTTP_PASSWORD environment variables in jmeter.sh.
      -->
      <AuthManager guiclass="AuthPanel" testclass="AuthManager" testname="HTTP Authorization Manager" enabled="true">
        <collectionProp name="AuthManager.auth_list">
          <elementProp name="" elementType="Authorization">
            <stringProp name="Authorization.url">${__P(protocol,https)}://${__P(host,localhost)}:${__P(port,443)}</stringProp>
            <stringProp name="Authorization.username">${__P(http_user,)}</stringProp>
            <stringProp name="Authorization.password">${__P(http_password,)}</stringProp>
            <stringProp name="Authorization.domain"></stringProp>
            <stringProp name="Authorization.realm"></stringProp>
          </elementProp>
        </collectionProp>
      </AuthManager>
      <hashTree/>

      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Client Threads" enabled="true">
        <stringProp name="ThreadGroup.num_threads">${__P(threads,1)}</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController">
          <stringProp name="LoopController.loops">${__P(max_loops,1)}</stringProp>
        </elementProp>
      </ThreadGroup>
      <hashTree>
        <!-- Each thread reads from client_dir/thread_N.tsv -->
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="Client Data" enabled="true">
          <stringProp name="filename">${__P(client_dir,clients)}/${__threadNum}.tsv</stringProp>
          <stringProp name="variableNames">counter,timestamp_offset,client_id,http_method,path,useragent</stringProp>
          <boolProp name="ignoreFirstLine">true</boolProp>
          <stringProp name="delimiter">\t</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">false</boolProp>
          <boolProp name="stopThread">true</boolProp>
          <stringProp name="shareMode">shareMode.currentThread</stringProp>
        </CSVDataSet>
        <hashTree/>

        <!--
            Notes so that I don't forget.

            Calculate delay as delta from previous offset, not absolute. This
            is necessary because the timestamp_offset is meant to be from the
            first launch of jmeter.

            Initially, I tried ConstantTimer.delay but that delay is relative to
            the previous request. So the timestamp_offset must be recalculated
            based the previous request finishing.

            If the previous request takes longer than the intended delay, then
            what ends up happening is I get a negative value. In this case, I
            set no delay because I want the request launched as fast as
            possible.

            This method isn't the best but I think it's the best I have. I
            can't think of a better way to try to emulate traffic from a
            production sample.
        -->
        <JSR223Timer guiclass="TestBeanGUI" testclass="JSR223Timer" testname="Replay Timer" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="script">
// Get current offset (seconds from test start)
def currentOffset = vars.get("timestamp_offset") as Double

// Get previous offset (default 0 for first request)
def prevOffset = vars.get("__prevOffset") as Double ?: 0.0

// Calculate delta in milliseconds
def deltaMs = ((currentOffset - prevOffset) * 1000) as Long

// Store current offset for next iteration
vars.put("__prevOffset", currentOffset.toString())

// Return delay (minimum 0 to handle any timing issues)
return Math.max(0, deltaMs)
          </stringProp>
        </JSR223Timer>
        <hashTree/>


        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Request" enabled="true">
          <stringProp name="HTTPSampler.protocol">${__P(protocol,https)}</stringProp>
          <stringProp name="HTTPSampler.domain">${__P(host,localhost)}</stringProp>
          <stringProp name="HTTPSampler.port">${__P(port,443)}</stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">${http_method}</stringProp>
          <!--
            Enable MD5 hash calculation for response body verification.
            The MD5 hash will be available in the sample result for saving.
          -->
          <boolProp name="HTTPSampler.md5">true</boolProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="Headers">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="User-Agent" elementType="Header">
                <stringProp name="Header.name">User-Agent</stringProp>
                <stringProp name="Header.value">${useragent}</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>

          <!--
            Save MD5 checksum for each request to a TSV file matching the client file.
            Creates checksums/N.tsv corresponding to clients/N.tsv with a 1:1 line mapping.
            Format: counter, client_id, http_method, path, response_code, md5_checksum (tab-separated)
            Uses captured vars from PreProcessor. Post-run sort handles ordering.
          -->
          <JSR223PostProcessor guiclass="TestBeanGUI" testclass="JSR223PostProcessor" testname="Save MD5 Checksum" enabled="true">
            <stringProp name="scriptLanguage">groovy</stringProp>
            <stringProp name="script">
def threadNum = ctx.getThreadNum() + 1
def checksumsDir = props.get("checksums_dir") ?: "checksums"
def clientDir = props.get("client_dir") ?: "clients"

// Get response data
def responseCode = prev.getResponseCode()
def md5Hash = ""
if (responseCode.startsWith("2")) {
    md5Hash = prev.getResponseDataAsString() ?: ""
}

// Get the actual URL path from the response
def actualPath = prev.getURL()?.getPath()
if (actualPath == null) {
    return
}

// Read CSV file to build a list of all rows with this path
def csvFile = new File(clientDir, threadNum + ".tsv")
def csvLines = csvFile.readLines()

// Find all CSV rows that match this path
def matchingRows = []
for (int i = 1; i &lt; csvLines.size(); i++) {
    def fields = csvLines[i].split("\t")
    if (fields.length &gt; 4 &amp;&amp; fields[4] == actualPath) {
        matchingRows.add([
            counter: fields[0],
            clientId: fields[2],
            method: fields[3],
            path: fields[4]
        ])
    }
}

if (matchingRows.isEmpty()) {
    return  // Path not found in CSV
}

// Use file locking to append result
def checksumFile = new File(checksumsDir, threadNum + ".tsv")
checksumFile.parentFile.mkdirs()

def raf = new RandomAccessFile(checksumFile, "rw")
def channel = raf.getChannel()
def lock = channel.lock()

try {
    // Read current file content
    def existingContent = ""
    def fileLen = checksumFile.length()
    if (fileLen &gt; 0) {
        def bytes = new byte[(int)fileLen]
        raf.seek(0)
        raf.readFully(bytes)
        existingContent = new String(bytes, "UTF-8")
    }

    // Count how many times this path has already been recorded
    def pathOccurrences = 0
    if (existingContent) {
        existingContent.split("\n").each { line -&gt;
            if (line.contains("\t${actualPath}\t")) {
                pathOccurrences++
            }
        }
    }

    // Get the matching row based on occurrence order
    if (pathOccurrences &gt;= matchingRows.size()) {
        return  // All occurrences of this path already recorded
    }
    def matchingRow = matchingRows[pathOccurrences]

    // Build new content
    def newContent = existingContent
    if (!newContent.startsWith("counter\t")) {
        newContent = "counter\tclient_id\thttp_method\tpath\tresponse_code\tmd5_checksum\n"
    }
    newContent += "${matchingRow.counter}\t${matchingRow.clientId}\t${matchingRow.method}\t${matchingRow.path}\t${responseCode}\t${md5Hash}\n"

    // Write back
    raf.seek(0)
    raf.setLength(0)
    raf.write(newContent.getBytes("UTF-8"))
} finally {
    lock.release()
    channel.close()
    raf.close()
}
            </stringProp>
          </JSR223PostProcessor>
          <hashTree/>
        </hashTree>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
